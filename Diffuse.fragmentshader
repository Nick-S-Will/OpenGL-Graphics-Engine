#version 330 // OpenGL version 3.3
#define LIGHT_COUNT 4

const int DIRECTIONAL_LIGHT = 0;
const int POINT_LIGHT = 1;
const int SPOT_LIGHT = 2;

struct Material
{
	float specularStrength;
	sampler2D diffuseTexture;
	sampler2D specularTexture;
};

struct Light
{
	vec3 position;
	vec3 direction;
	vec3 color;
	vec3 specularColor;

	float constant;
	float linear;
	float quadratic;

	float coneAngle;
	float persistence;
	int type;
	bool isEnabled;
};

in vec3 retPos;
in vec3 retNormal;
in vec2 retTexCoord;
in vec3 retViewDirection;

uniform Material material;
uniform Light lights[LIGHT_COUNT];
uniform vec3 ambientColor;

out vec4 FragColor;

vec4 getAmbientColor()
{
	vec3 ambient = texture(material.diffuseTexture, retTexCoord).rgb * ambientColor;
	return vec4(ambient, 1.f);
}

vec4 getLitColor(Light light, float alignmentThreshold, float alignmentFactor)
{
	if (light.type == SPOT_LIGHT && alignmentThreshold > alignmentFactor) return vec4(0.f);

	vec3 directionToLight = light.type == DIRECTIONAL_LIGHT ? -light.direction : normalize(light.position - retPos);
	float lambertianStrength = dot(directionToLight, retNormal);
	vec3 lambertian = lambertianStrength * texture(material.diffuseTexture, retTexCoord).rgb * light.color;

	vec3 refl = reflect(-directionToLight, retNormal);
	float specularStrength = pow(max(dot(refl, retViewDirection), 0.f), material.specularStrength);
	vec3 specular = specularStrength * texture(material.specularTexture, retTexCoord).rgb * light.specularColor;

	vec3 litColor = lambertian + specular;
	if (light.type == SPOT_LIGHT)
	{
		float lightDistance = length(light.position - retPos);
		float attenuation = 1.f / (light.constant + light.linear * lightDistance + light.quadratic * (lightDistance * lightDistance));
		attenuation *= 1 - pow(clamp(alignmentThreshold / alignmentFactor, 0.f, 1.f), light.persistence);
		litColor *= attenuation;
	}

	return vec4(litColor, 1.f);
}

void main()
{
	vec4 color = getAmbientColor();
	for (int i = 0; i < LIGHT_COUNT; i++)
	{
		if (!lights[i].isEnabled) continue;

		vec3 lightDirectionToPixel = normalize(retPos - lights[i].position);
		float alignmentThreshold = cos(lights[i].coneAngle);
		float alignmentFactor = dot(normalize(lights[i].direction), lightDirectionToPixel);
		color += getLitColor(lights[i], alignmentThreshold, alignmentFactor);
	}
	
	FragColor = color;
}